export NVM_DIR="$HOME/.nvm" && source "$NVM_DIR/nvm.sh"
export GROOVY_HOME=/usr/local/opt/groovy/libexec
export KUB_HOME="$HOME/.kube"

# Use 'npx' instead of this
# export PATH=$(npm bin):$PATH

# Kubernetes aliases.
alias kubectl-alias-name='kubectl -n prod "$@" --kubeconfig="$KUB_HOME/kubectl-config"'

alias gitrepo='chrome `git-remote-url origin`'

# Set up aliases for changing java versions quickly. 
for version in 1.7 1.8 11; do
  v="${version//\./_}"
	v="${v//1_/}"
	h=JAVA_"$v"_HOME

  # This creates an env variable for each java version
  export "$h"=$(/usr/libexec/java_home -v $version)
	
  # This creates an alias that allows changing java versions
	alias "java-$v"="export JAVA_HOME=\$$h; java -version"
done

git-remote-url() {
 local rmt=$1; shift || { printf "Usage: git-remote-url [REMOTE]\n" >&2; return 1; }
 local url

 if ! git config --get remote.${rmt}.url &>/dev/null; then
  printf "%s\n" "Error: not a valid remote name" && return 1
  # Verify remote using 'git remote -v' command
 fi

 url=`git config --get remote.${rmt}.url`

 # Parse remote if local clone used SSH checkout
 [[ "$url" == git@* ]] && {
 	url="${url##*@}" >&2; # Extract substring from "@"
 	url="${url%%.git}" >&2; # Extract substring until ".git"
 	url="http://${url%%:*}/${url##*:}"
 };

 printf "%s\n" "$url"
}
